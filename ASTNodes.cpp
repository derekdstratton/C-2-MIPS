#include <utility>

//Include statements

#include "ASTNodes.h"

//Extern variables and functions
extern int yylineno;
extern deque <char> columnQueue;
extern int yyleng;
extern void outputError(string errmsg1, string errmsg2, bool errtype);
extern char* fileName;
extern string THREEACPATH;

//Static Variables

int ASTNode::registerCnt = 0;
int ASTNode::floatRegisterCnt = 0;
int ASTNode::labelCnt = 0;
vector<vector<string>> ASTNode::main3ac;
int ASTNode::stackCnt = 0;
map<string, map<string, int>> ASTNode::allFuncOffsets;
map<string, int> ASTNode::currentFuncOffsets;

//Helper Functions

/**
 *
 * @param lineNum
 * @return
 */
string getFileLine(int lineNum){
    ifstream istream;
    istream.open(fileName);
    string s;
    int temp = 0;
    for(int i = 0; i < lineNum; ++i)
    {
        getline(istream, s);
    }

    while(s[temp] == ' ')
        temp++;

    s.erase(1, temp - 1);
    s = "line " + to_string(lineNum) + ": " + s;
    return s;
}

/**
 * Returns the size in bytes of a type
 * @param typeSet
 * @return
 */
int getByteSize(set<int> typeSet) {
    if (typeSet.count(CHAR) == 1) {
        return 1;
    }
    if (typeSet.count(SHORT) == 1) {
        return 2;
    }
    if (typeSet.count(INT) == 1 && typeSet.count(UNSIGNED) == 1) {
        return 4;
    }
    if (typeSet.count(INT) == 1) {
        return 4;
    }
    if (typeSet.count(LONG) == 1) {
        return 8;
    }
    if (typeSet.count(FLOAT) == 1) {
        return 4;
    }
    if (typeSet.count(DOUBLE) == 1) {
        return 8;
    }
    cerr << "SHOULDNT BE HERE BAD TYPE";
    exit(1);
    return -1;
}

//ASTNode Functions

/**
 * @brief helper function to access ASTNode children
 * @return returns all children nodes from an ASTNode in the form of a list of AST pointers.
 */
list<ASTNode *> ASTNode::getChildren() {
    return childrenNodes;
}

/**
 *
 * @return
 */
int ASTNode::getLineNum(){
    return lineNum;
}

/**
 * @brief copies AST generated by parser into a tree form tree.hh
 * @param root is the root of the parser AST tree
 * @param ast is the tree.hh tree
 */
void ASTNode::copyTree(ASTNode *&root, tree<ASTNode *> &ast) {
    //Make sure the ast is clear
    ast.clear();
    //first insert the top
    auto firstNode = ast.insert(ast.begin(), root);
    //now add the children
    copyTreeHelper(root, ast, firstNode);

}

/**
 * @brief function to get set types from ASTNode. Should not be used for base class
 * @return returns an empty set that is sad
 */
set<int> ASTNode::getTypes() {
    cerr << "IF YOU'RE SEEING THIS DIE" << endl;
    set<int> fail;
    return fail;
}

void ASTNode::setTypes(set<int> copy){
    cerr << "IF YOU'RE SEEING THIS TAMALE" << endl;
    return;
}

/**
 *
 * @return
 */
int ASTNode::getDimensions() {
    return 0;
}

/**
 * @brief function to get name from ASTNode. Should not be used for base class
 * @return returns a null pointer
 */
string ASTNode::getName() {
    cerr << "IF YOURE SEEING THIS RIP" << endl;
    cout << "DEAD FROM GETNAME" << endl;
    exit(1);
    return nullptr;
}

/**
 * @brief function to get sizes from ASTNode. Should not be used for base class
 * @return returns an empty ASTNode pointer list
 */
list<ASTNode*> ASTNode::getSizes() {
    list<ASTNode*> empty;
    return empty;
}

/**
 * @brief function to set SymbolTableNode in an ASTNode. Should not be used for base class
 * @param symtblnd2 is the symbol table node to be inserted
 */
void ASTNode::setSymbolNode(SymbolTableNode2* symtblnd2) {
    cerr << "IF YOURE SEEING THIS RAVIOLI" << endl;
}

/**
 * @brief extraction operator overload to print ASTNode to a stream
 * @param os is the stream to be used
 * @param node is the ASTNode to be printed
 * @return returns the stream
 */
std::ostream &operator<<(std::ostream &os, const ASTNode &node) {
    node.printNode(os);
    return os;
}

/**
 * @brief returns a number based on the first data type found in the set
 * @param typeSet is the set to be searched
 * @return returns a number. The number is larger for longer data types
 */
int computeTypeOrder(set<int> &typeSet) {
    if (typeSet.count(CHAR) == 1) {
        return 1;
    }
    if (typeSet.count(SHORT) == 1) {
        return 2;
    }
    if (typeSet.count(INT) == 1 && typeSet.count(UNSIGNED) == 1) {
        return 3;
    }
    if (typeSet.count(INT) == 1) {
        return 4;
    }
    if (typeSet.count(LONG) == 1) {
        return 5;
    }
    if (typeSet.count(FLOAT) == 1) {
        return 6;
    }
    if (typeSet.count(DOUBLE) == 1) {
        return 7;
    }
    cerr << "SHOULDNT BE HERE, TYPE NOT FOUND MAYDAY MAYDAY";
    return -1;
}

/**
 * @brief function to compare two sets for cast
 * @param left is one of the sets to be compared
 * @param right is the other set to be compared
 * @return returns the value of computing type order of left - right.
 *         if returned value is >0, then right side needs to be cast.
 *         if returned value is <0, then left side needs to be cast.
 */
int compareForCast(set<int> &left, set<int> &right) {

    int leftSize = computeTypeOrder(left);
    int rightSize = computeTypeOrder(right);
    return leftSize - rightSize;

}

/**
 * @brief function to print base ASTNode.
 * @param os stream to be printed to
 */
void ASTNode::printNode(std::ostream &os) const {
    os << "NOT_PROGRAMMED";
}

/**
 * @brief helper function to copy AST into a tree.hh tree
 * @param src_node is the root node of the AST generated by parser
 * @param ast is the tree.hh tree to be copied to
 * @param iRoot is the iterator to iterate through the children
 */
void ASTNode::copyTreeHelper(ASTNode *&src_node, tree<ASTNode *> &ast, typename tree<ASTNode *>::iterator iRoot) {
    //Node has children, insert them
    if (!src_node->getChildren().empty()) {
        for (auto &child : src_node->getChildren()) {
            auto newRoot = ast.append_child(iRoot, child);
            copyTreeHelper(child, ast, newRoot);
        }
    }
}

void ASTNode::output3ac() {
    //Outputs the vector to a file
    ofstream f;
    f.open(THREEACPATH);
    for (auto x : main3ac) {
        for (const auto &y: x) {
            cout << setw(18) << left << y;
            f << setw(18) << left << y;
        }
        f << endl;
        cout << endl;
    }
    f.close();
}

/**
 *
 * @return
 */
vector<vector<string>> ASTNode::get3ac() {
    return main3ac;
}

/**
 * @brief default constructor for ASTNode
 */
ASTNode::ASTNode() = default;

/**
 *
 * @return
 */
int ASTNode::getNodeType() {
    return ASTNODE;
}

list<pair<string, set<int>>> ASTNode::getArgs() {
    cerr << "HOLY ROLI THE RIGALONI" << endl;
    list<pair<string, set<int>>> a;
    return a;
}
/**
 *
 * @return
 */
string ASTNode::walk() {
    cerr << "WALKING UNDEFINED NODE" << endl;
    for (auto x : getChildren()) {
        x->walk();
    }
    return "";
}

/**
 *
 * @return
 */
int ASTNode::getVal() {
    cerr << "OH NO GOVERNOR MY BLOODY TEA NIGEL" << endl;
    return -1;
}

list<int> ASTNode::getSizeList() {
    cerr << "SIZE LIST SAYS WHAT" << endl;
    list<int> k;
    return k;
}

int IdentifierNode::getVal() {
    return atoi(identifier.c_str());
}

/**
 * @brief default constructor for TypeNode
 * default- MUST set type in derived constructor
   also must CHECK type in derived constructor after setting it.
 */
TypeNode::TypeNode() = default;

/**
 *
 */
void TypeNode::checkType() {
    bool goodType = true;
    int typeCount = 0;

    if (types.count(CHAR) == 1) {
        typeCount++;
    }
    if (types.count(SHORT) == 1) {
        typeCount++;
    }
    if (types.count(INT) == 1) {
        typeCount++;
    }
    if (types.count(LONG) == 1) {
        typeCount++;
    }
    if (types.count(FLOAT) == 1) {
        typeCount++;
    }
    if (types.count(DOUBLE) == 1) {
        typeCount++;
    }
    if (typeCount >= 2) {
        goodType = false;
    }
    if (!goodType) {
        outputError("Bad type", "Defined type is not a logical type", false);
    }
}

/**
 * @brief TypeNode constructor with a set of types
 * @param type is the set of types
 */
TypeNode::TypeNode(set<int> &type) {
    types = type;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 *
 * @return
 */
set<int> TypeNode::getTypes() {
    return types;
}

/**
 * @brief print function for TypeNode that checks type with tokenToString2
 * @param os is the stream to be printed to
 */
void TypeNode::printNode(std::ostream &os) const {
    os << "TYPE_";
    for (int i : types) {
        os << tokenToString2(i);
    }
}

/**
 *
 * @return
 */
int TypeNode::getNodeType() {
    return TYPENODE;
}

/**
 *
 * @return
 */
string TypeNode::walk() {
    return "";
}


/**
 * @brief ArrayNode constructor creates a templist with the identifier and the dimensions
 * @param var is the identifier along with the type
 * @param sizes is the dimensions of the array
 */
ArrayNode::ArrayNode(ASTNode *var, list<ASTNode *> sizes) {
    list<ASTNode*> tmplist;
    tmplist = sizes;
    tmplist.push_front(var);
    sizeList = sizes;
    childrenNodes = tmplist;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
    types = var->getTypes();
    checkType();
}

/**
 *
 * @return
 */
int ArrayNode::getDimensions() {
    int arrSize = getChildren().front()->getDimensions();
    int derefs = sizeList.size();
    return arrSize - derefs;
}

/**
 * @brief function to get dimensions of an arrayNode
 * @return list of ASTNode pointers that are the dimensions
 */
list<ASTNode*> ArrayNode::getSizes() {
    return sizeList;
}

/**
 * @brief print function for arrayNode
 * @param os is the stream to be printed to
 */
void ArrayNode::printNode(std::ostream &os) const {
    os << "ARRAY";
}

/**
 *
 * @return
 */
int ArrayNode::getNodeType() {
    return ARRAYNODE;
}

/**
 *
 * @return
 */
string ArrayNode::walk() {
    string s4 = getFileLine(lineNum);
    string s1 = "$t" + to_string(registerCnt++ % 10);
    int baseOffset = currentFuncOffsets.at(getChildren().front()->getName());
    string name = to_string(baseOffset) + "($fp)";
    vector<string> v = {"ADDR", name, "---", s1};
    vector<string> v4 = {"COMMENT", s4};
    main3ac.push_back(v4);
    main3ac.push_back(v);
    //s1 is the base address


    //string s2 = "$t" + to_string(registerCnt++ % 10);
    //string index_offset = getChildren().back()->walk();
    string size_of = to_string(getByteSize(getChildren().front()->getTypes()));

    //vector<string> v2 = {"STAR", index_offset, size_of, s2};
    //main3ac.push_back(v4);
    //main3ac.push_back(v2);
    //s2 is the offset

    //s2 to compute the offset
    int i = getChildren().front()->getDimensions();
    cerr << "DIMENSIONS: " << i << endl;
    string s5 = "1";
    string s6;
    string s7;
    string s8 = "$zero";
    string s9;
    for (auto sizeIndex : sizeList) {
        s5 = "1";
        auto list_copy = getChildren().front()->getSizeList();
        while (i > 1) {
            s6 = "$t" + to_string(registerCnt++ % 10);
            vector<string> v2 = {"STAR", to_string(list_copy.front()), s5, s6};
            list_copy.pop_front();
            main3ac.push_back(v2);
            s5 = s6;
            //cerr << "THE THING" << to_string(*reverse_it) << " ";
            i--;
            //reverse_it++;
        }
        s7 = "$t" + to_string(registerCnt++ % 10);
        vector<string> v9 = {"STAR", sizeIndex->walk(), s5, s7};
        main3ac.push_back(v9);
        s9 = "$t" + to_string(registerCnt++ % 10);
        vector<string> v10 = {"PLUS", s7, s8, s9};
        main3ac.push_back(v10);
        s8 = s9;
        cerr << sizeIndex->walk() << endl;
    }
    string s10 = "$t" + to_string(registerCnt++ % 10);
    vector<string> v8 = {"STAR", size_of, s9, s10};
    main3ac.push_back(v8);
    cerr << "MULTIPLY ALL OF THAT BY " << size_of << endl;
    //s10 is now that big offset

    //base + offset
    string s3 = "$t" + to_string(registerCnt++ % 10);
    vector<string> v3 = {"PLUS", s1, s10, s3};
    main3ac.push_back(v4);
    main3ac.push_back(v3);
    return s3;
}

/**
 * @brief AssignNode constructor. Makes a types set based on the lval and a temporary list of child nodes.
 * @param lvalue is the lval of the assignment expression
 * @param rvalue is the rval of the assignment expression
 */
AssignNode::AssignNode(ASTNode *lvalue, ASTNode *rvalue) {
    list <ASTNode*> tmplist;

    int leftArrDims = lvalue->getDimensions();
    int rightArrDims = rvalue->getDimensions();
    cout << "LEFT arr dims: " << leftArrDims << endl;
    cout << "RIGHT arr dims: " << rightArrDims << endl;

    //Check for type mismatch (arrays)
    if (leftArrDims != rightArrDims) {
        //outputError("Semantic Error", "Mismatch of types in Array assignment", false); //todo breaks in bubble sort (???)
        cerr << "oops";
    }

    ASTNode * newLeft;
    ASTNode * newRight;

    set<int> leftSet = lvalue->getTypes();
    set<int> rightSet = rvalue->getTypes();
        //todo make sure this type works for function call nodes

    //Implicit casting
    int ret = compareForCast(leftSet, rightSet);
    if (ret != 0) {
        ASTNode *newtype = new TypeNode(leftSet);
        newLeft = lvalue;
        newRight = new CastNode(newtype, rvalue);
        tmplist.push_back(newLeft);
        tmplist.push_back(newRight);
        //types = leftSet;
        outputError("Cast", "Implicit Casting of types for assignment", true);
    } else {
        tmplist.push_back(lvalue);
        tmplist.push_back(rvalue);
        //types = leftSet;
    }

    types = leftSet;
    childrenNodes = tmplist;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for AssignNodes
 * @param os is the stream to be printed to
 */
void AssignNode::printNode(std::ostream &os) const {
    os << "ASSIGN";
}

/**
 *
 * @return
 */
int AssignNode::getNodeType() {
    return ASSIGNNODE;
}

/**
 *
 * @return
 */
string AssignNode::walk() {
    string s1 = "ASSIGN";
    string s2 = getChildren().back()->walk();
    string s3 = getChildren().front()->walk();
    string s4;
    if (getChildren().front()->getNodeType() == ARRAYNODE) {
        s3 = "(" + s3 + ")";
    }
    if (getChildren().back()->getNodeType() == ARRAYNODE) {
        s2 = "(" + s2 + ")";
    }

    s4 = getFileLine(lineNum);

    vector<string> v2 = {"COMMENT", s4};
    vector<string> v = {s1, s2, "---", s3};
    main3ac.push_back(v2);
    main3ac.push_back(v);
    return s3;
}

/**
 * @brief BinaryMathNode constructor. Creates a temporary list of child nodes
 *        Checks if a node needs to be cast. If it does, creates a cast node accordingly.
 * @param type is the type of binary math operator
 * @param left is the left child
 * @param right is the right child
 */
BinaryMathNode::BinaryMathNode(int type, ASTNode *left, ASTNode *right) {
    operationType = type;
    list<ASTNode*> tmplist;

    ASTNode * newLeft;
    ASTNode * newRight;

    set<int> leftSet = left->getTypes();
    int leftArrDims = left->getDimensions();
    set<int> rightSet = right->getTypes();
    int rightArrDims = right->getDimensions();

    //Check for type mismatch (arrays)
    if (leftArrDims != rightArrDims) {
        outputError("Semantic Error", "Mismatch of types in Array operation", false);
    }

    //Implicit casting
    int ret = compareForCast(leftSet, rightSet);
    if (ret < 0) {
        //Cast the node on the left to the type of the right node
        ASTNode * newtype = new TypeNode(rightSet);
        newLeft = new CastNode(newtype, left);
        newRight = right;
        tmplist.push_back(newLeft);
        tmplist.push_back(newRight);
        types = rightSet;
        outputError("Cast", "Implicit Casting of types for operation", true);
    } else if (ret > 0) {
        //Cast the node on the right to the type of the left node
        ASTNode * newtype = new TypeNode(leftSet);
        newRight = new CastNode(newtype, right);
        newLeft = left;
        tmplist.push_back(newLeft);
        tmplist.push_back(newRight);
        types = leftSet;
        outputError("Cast", "Implicit Casting of types for operation", true);
    } else {
        tmplist.push_back(left);
        tmplist.push_back(right);
        types = leftSet;
    }
    checkType();

    childrenNodes = tmplist;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief binaryMathNode print function
 * @param os is the stream to be printed to
 */
void BinaryMathNode::printNode(std::ostream &os) const {
    os << "OPERATION_" << tokenToString2(operationType);
    for (auto item : types) {
        os << "_" << tokenToString2(item);
    }
}

/**
 *
 * @return
 */
int BinaryMathNode::getNodeType() {
    return BINARYMATHNODE;
}

/**
 *
 * @return
 */
string BinaryMathNode::walk() {
    string s1 = tokenToString2(operationType);

    string s2 = getChildren().front()->walk();
    if(getChildren().front()->getNodeType() == ARRAYNODE){
        s2 = "(" + s2 + ")";
    }

    string s3 = getChildren().back()->walk();
    if(getChildren().back()->getNodeType() == ARRAYNODE){
        s3 = "(" + s3 + ")";
    }

    string s4;
    if(getChildren().front()->getTypes().count(298) || getChildren().front()->getTypes().count(299) ||
            getChildren().back()->getTypes().count(298) || getChildren().back()->getTypes().count(299))
        s4 = "$f" + to_string(floatRegisterCnt++);
    else
        s4 = "$t" + to_string(registerCnt++ % 10);

    string s5;

    s5 = getFileLine(lineNum);

    vector<string> v2 = {"COMMENT", s5};
    vector<string> v = {s1, s2, s3, s4};
    main3ac.push_back(v2);
    main3ac.push_back(v);
    return s4;
}

/**
 * @brief Bitwise Node constructor
 * @details uses compareForCast to check if either child needs to be cast.
 *          If needed, creates a CastNode accordingly.
 *          makes a temporary list of the children and sets childrenNodes equal to it.
 * @param x is the bitwise operation
 * @param left is the left child of the operator
 * @param right is the right child of the operator
 */
BitwiseNode::BitwiseNode(int x, ASTNode *left, ASTNode *right) {
    nodeType = x;
    list<ASTNode*> tmplist;

    ASTNode * newLeft;
    ASTNode * newRight;

    set<int> leftSet = left->getTypes();
    set<int> rightSet = right->getTypes();
    int ret = compareForCast(leftSet, rightSet);
    if (ret < 0) {
        //Cast the node on the left to the type of the right node
        ASTNode * newtype = new TypeNode(rightSet);
        newLeft = new CastNode(newtype, left);
        newRight = right;
        tmplist.push_back(newLeft);
        tmplist.push_back(newRight);
        types = rightSet;
    } else if (ret > 0) {
        //Cast the node on the right to the type of the left node
        ASTNode * newtype = new TypeNode(leftSet);
        newRight = new CastNode(newtype, right);
        newLeft = left;
        tmplist.push_back(newLeft);
        tmplist.push_back(newRight);
        types = leftSet;
    } else {
        tmplist.push_back(left);
        tmplist.push_back(right);
        types = leftSet;
    }

    childrenNodes = tmplist;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 *
 * @return
 */
int BitwiseNode::getNodeType() {
    return BITWISENODE;
}

/**
 *
 * @param os
 */
void BitwiseNode::printNode(std::ostream &os) const {
    os << "BITWISE_" << tokenToString2(nodeType);
}

/**
 * @brief CastNode constructor. Creates a temporary list of child nodes
 * @param type is the type that the right child should be cast to
 * @param nodeToCast is the node that should be cast to a different type
 */
CastNode::CastNode(ASTNode *type, ASTNode *nodeToCast) {
    list<ASTNode *> tmplist;
    tmplist.push_back(type);
    tmplist.push_back(nodeToCast);
    childrenNodes = tmplist;
    types = type->getTypes();
    checkType();

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for castNode
 * @param os is the stream to be printed to
 */
void CastNode::printNode(std::ostream &os) const {
    os << "CAST";
}

/**
 *
 * @return
 */
int CastNode::getNodeType() {
    return CASTNODE;
}

/**
 *
 * @return
 */
string CastNode::walk(){//only need to cast in 3ac if between double/float and anything else
    string s1;
    string s2;
    vector<string> v;
    if(getChildren().front()->getTypes().count(298) || getChildren().front()->getTypes().count(299)){
        s1 = getChildren().back()->walk();
        s2 = "$f" + to_string(floatRegisterCnt++);
        v = {"ASSIGN", s1, "---", s2};
    }
    else{
        s1 = getChildren().back()->walk();
        s2 = "$t" + to_string(registerCnt++ % 10);
        v = {"ASSIGN", s1, "---", s2};
    }
    vector<string> v2;
    v2 = {"COMMENT", getFileLine(lineNum)};
    main3ac.push_back(v2);
    main3ac.push_back(v);
    return s2;
}

/**
 * @brief DeclNode constructor. Creates a temp list of children
 * @param first is the first child node
 * @param second is the second child node
 */
DeclNode::DeclNode(ASTNode *first, ASTNode *second) {
    list<ASTNode*> tmpList;
    tmpList.push_back(first);
    tmpList.push_back(second);
    childrenNodes = tmpList;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print DeclNode
 * @param os is the stream to be printed to
 */
void DeclNode::printNode(std::ostream &os) const {
    os << "DECLARATION";
}

/**
 *
 * @return
 */
int DeclNode::getNodeType() {
    return DECLNODE;
}

/**
 *
 * @return
 */
string DeclNode::walk() {
    if (getChildren().back()->getNodeType() == ARRAYNODE) {
        currentFuncOffsets.emplace(getChildren().back()->getChildren().front()->getName(), stackCnt);
        int k = 1;
        for (auto i : getChildren().back()->getSizes()) {
            k *= i->getVal();
        }
        //stackCnt += getByteSize(getChildren().back()->getChildren().front()->getTypes())*k;
        stackCnt += 4*k;
        return "";
    } else {
        currentFuncOffsets.emplace(getChildren().back()->getName(), stackCnt);
        //stackCnt += getByteSize(getChildren().back()->getTypes());
        stackCnt += 4;
    }
    return "";
}


/**
 * @brief ForNode constructor. Stores a ASTNode* list of the expressions and an bool array
 *        with values corresponding to which expressions are written
 * @param ptrList is the list of expressions
 * @param arr is the bool array denoting which expressions are written
 * @param stmt is the statement or the body of the loop
 */
ForNode::ForNode(list<ASTNode *> ptrList, bool *arr, ASTNode * stmt) {
    childrenNodes = move(ptrList);
    childrenNodes.push_back(stmt);
    for(int i = 0; i < 3; ++i)
        stmtWritten[i] = arr[i];
}

void ForNode::printNode(std::ostream &os) const{
    os << "FOR";
}

/**
 *
 * @return
 */
string ForNode::walk() {
    if (stmtWritten[0]) {
        getChildren().front()->walk();
    }
    string s5;
    s5 = getFileLine(getChildren().front()->getLineNum());
    string initLabel = "l" + to_string(labelCnt++);
    vector<string> v = {"LABEL", initLabel, "---", "---"};
    vector<string> v4 = {"COMMENT", s5};
    main3ac.push_back(v4);
    main3ac.push_back(v);

    string endLabel = "l" + to_string(labelCnt++);

    if (stmtWritten[1]) {
        auto list_copy = getChildren();
        if (stmtWritten[0])
            list_copy.pop_front();
        string s1 = "BREQ";
        string s2 = list_copy.front()->walk();
        string s3 = "$zero";
        vector<string> v5 = {s1, s2, s3, endLabel};
        main3ac.push_back(v5);
    }
    getChildren().back()->walk();
    if (stmtWritten[2]) {
        auto list_copy = getChildren();
        if (stmtWritten[0])
            list_copy.pop_front();
        if (stmtWritten[1])
            list_copy.pop_front();
        list_copy.front()->walk();
    }
    vector<string> v2 = {"BR", "---", "---", initLabel};
    main3ac.push_back(v2);
    vector<string> v3 = {"LABEL", endLabel, "---", "---"};
    main3ac.push_back(v3);

    return "";
}


/**
 * @brief FuncNode constructor. Uses a switch statement to construct appropriate member fields.
 *        If function prototype, sets name and param types.
 *        If function definition, sets name, return type, name and type of parameters, and children nodes (what is inside curly braces)
 *        Additionally makes a TypeNode as a child denoting return type.
 *        If function call, sets given arguments as children nodes.
 * @param name is the function name
 * @param typef
 * @param params
 */
FuncNode::FuncNode(string name, list<set<int>> types, list<ASTNode*> children, list<pair<string, set<int>>> arguments, int type)
{
    funcName = move(name);
    funcType = type;
    switch(type)
    {
        case 0: {
            paramTypes = types;
            args = move(arguments);
            break;
        }
        case 1: {
            paramTypes = types;
            args = move(arguments);
            childrenNodes = children;
            auto tempIt = types.begin();
            childrenNodes.push_front(new TypeNode(*tempIt));
            break;
        }
        case 2: {
            paramTypes = types;
            childrenNodes = children;
            break;
        }
        default:
            break;
    }
}

list<pair<string, set<int>>> FuncNode::getArgs(){
    return args;
}

/**
 * @brief function to print funcnodes. Uses a switch statement to print different types of funcnodes.
 *        If function prototype, prints name and param types.
 *        If function definition, prints name and param names and types.
 *        If function call, prints name and args if they are given.
 * @param os is the stream to be printed to
 */
void FuncNode::printNode(std::ostream &os) const{
    switch(funcType)
    {
        /*case 0: {
            os << "FUNCTION_PROTOTYPE_" << funcName;
            for (const auto &paramType : paramTypes) {
                os << "_";
                for (int ite : paramType)
                    os << tokenToString2(ite);
            }
            break;
        }*/
        case 1: {
            os << "FUNCTION_DEFINITION_" << funcName;
            for (const auto &arg : args) {
                os << "_";
                os << arg.first << "_";
                for (int ite : arg.second)
                    os << tokenToString2(ite);
            }
            break;
        }
        case 2: {
            os << "FUNCTION_CALL_" << funcName;
            break;
        }
        default:
            break;
    }
}

/**
 * @brief function that returns the name of a funcnode
 *
 */
string FuncNode::getName(){
    return funcName;
}

/**
 *
 * @return
 */
int FuncNode::getNodeType() {
    return FUNCNODE;
}

void FuncNode::setTypes(set<int> copy) {
    types = copy;
}

/**
 *
 * @return
 */
string FuncNode::walk() {
    switch (funcType) {
        case 0: {
            break;
        }
        case 1: {
            stackCnt = 0;
            currentFuncOffsets.clear();
            vector<string> v9 = {"COMMENT", "Function: " + funcName, "---", "---"};
            main3ac.push_back(v9);
            vector<string> v = {"LABEL", funcName, "---", "---"};
            main3ac.push_back(v);

            currentFuncOffsets.emplace("_RETURN_ADDRESS_", stackCnt);
            stackCnt += 4; //todo I'm assuming each address is 4 bytes

            for (auto arg : args) {
                currentFuncOffsets.emplace(arg.first, stackCnt);
                //stackCnt += getByteSize(arg.second);
                stackCnt += 4;
            }
            for (auto a : getChildren()) {
                a->walk();
            }
            vector<string> v2 = {"RETURN", "---", "---", "---"};
            main3ac.push_back(v2);

            currentFuncOffsets.emplace("_TOTAL_STACK_SIZE_", stackCnt);
            allFuncOffsets.emplace(funcName, currentFuncOffsets);
            break;
        }
            //num local variables known after doing a walk, based on offset symbol table
        case 2: {
            if (funcName == "writeint") {
                vector<string> v = {"WRITEINT", getChildren().front()->getChildren().front()->walk(), "---", "---"};
                main3ac.push_back(v);
                return "";
            }
            if (funcName == "writechar") {
                vector<string> v = {"WRITECHAR", getChildren().front()->getChildren().front()->walk(), "---", "---"};
                main3ac.push_back(v);
                return "";
            }
            if (funcName == "readint") {
                string reg = "$t" + to_string(registerCnt++);
                vector<string> v = {"READINT", reg, "---", "---"};
                main3ac.push_back(v);
                return reg;
            }
            if (funcName == "readchar") {
                string reg = "$t" + to_string(registerCnt++);
                vector<string> v = {"READCHAR", reg, "---", "---"};
                main3ac.push_back(v);
                return reg;
            }
            int stackSpace = 0;
            /*for (const auto &item : paramTypes) { //todo this is porbably sketchy
                stackSpace += getByteSize(item);
            }*/
            stackSpace = allFuncOffsets.at(funcName).at("_TOTAL_STACK_SIZE_");
            vector<string> v = {"ALLOCATE", to_string(stackSpace), "---", "---"};
            main3ac.push_back(v);

            vector<string> v7 = {"PUSHRA", "---", "---", "---"}; //pushes the return address on the stack
            //doing this allows for nested function calls/recursion so each stack frame saves the location
            //of its caller on the stack. This is at the top of the stack, and must be loaded whenever
            //returning from a function
            main3ac.push_back(v7);

            int k = 0;
            if (!getChildren().empty()) {
                for (auto a : getChildren().front()->getChildren()) { //the child is always an "arguments" node, so look at his children
                    string ret = a->walk();
                    //todo this k thing here is basically assuming all the parameters are word length.
                    //i don't know how we would get the info we need for an array, so array parameters would
                    //need a lot of work right here if we want that
                    k += 4;
                    vector<string> v2 = {"PUSHPARAM", ret, to_string(k) + "($fp)", "---"};
                    main3ac.push_back(v2);
                }
            }
            vector<string> v2 = {"CALL", funcName, "---", "---"};
            main3ac.push_back(v2);

            string s = "$t" + to_string(registerCnt++ % 10);
            string s2 = to_string(allFuncOffsets.at(funcName).at("_RETURN_VALUE_"));
            vector<string> v3 = {"ASSIGN", s2 + "($fp)", "---", s};
            main3ac.push_back(v3);
            vector<string> v4 = {"DEALLOCATE", to_string(stackSpace), "---", "---"};
            main3ac.push_back(v4);
            return s;
        }
        default:
            break;
    }
    return "";
}

/**
 * @brief IfNode constructor for if statement.
 *        Creates a temporary list of child nodes and sets childrenNodes equal to it.
 * @param expr is the expression to be checked
 * @param stmt is the body of the if statement
 */
IfNode::IfNode(ASTNode *expr, ASTNode *stmt) {
    list<ASTNode*> tempList;
    tempList.push_back(expr);
    tempList.push_back(stmt);
    childrenNodes = tempList;
    flag = true;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief IfNode constructor for if-else statement
 *        Creates a temporary list of child nodes and sets childrenNodes equal to it.
 * @param expr is the expression to be checked
 * @param stmt is the body of the if statement
 * @param stmt2 is the body of the else statement
 */
IfNode::IfNode(ASTNode *expr, ASTNode *stmt, ASTNode *stmt2) {
    list<ASTNode*> tempList;
    tempList.push_back(expr);
    tempList.push_back(stmt);
    tempList.push_back(stmt2);
    childrenNodes = tempList;
    flag = false;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for IfNode. Checks if it is an if statement or an if-else statement.
 * @param os is the stream to be printed to
 */
void IfNode::printNode(std::ostream &os) const {
    if(flag){
        os << "IF_NODE";
    }
    else{
        os << "IF_ELSE_NODE";
    }
}

/**
 *
 * @return
 */
int IfNode::getNodeType() {
    return IFNODE;
}

/**
 *
 * @return
 */
string IfNode::walk() {
    string s1 = "BREQ";
    string s2 = getChildren().front()->walk();
    string s3 = "$zero";
    string s4 = "l" + to_string(labelCnt++);
    string s5;
    s5 = getFileLine(getChildren().front()->getLineNum());
    vector<string> v3 = {"COMMENT", s5};
    vector<string> v = {s1, s2, s3, s4};
    main3ac.push_back(v);
    auto tmp = getChildren();
    tmp.pop_front();
    tmp.front()->walk();
    string s6;
    if (flag == 0) {
        s6 = "l" + to_string(labelCnt++);
        vector<string> v8 = {"BR", "---", "---", s6};
        main3ac.push_back(v8);
    }
    vector<string> v2 = {"LABEL", s4, "---", "---"};
    main3ac.push_back(v2);
    if (flag == 0) {
        getChildren().back()->walk();
        vector<string> v9 = {"LABEL", s6, "---", "---"};
        main3ac.push_back(v9);
    }
    //todo handle else statement (flag == 0)
    return "";
}

/**
 * @brief LogicalNode constructor. Creates a temporary list of child nodes
 * @param x is the type of logical operator that nodeType is set to.
 * @param left is the left child of the operator
 * @param right is the right child of the operator
 */
LogicalNode::LogicalNode(int x, ASTNode *left, ASTNode *right) {
    list <ASTNode*> tempList;
    tempList.push_back(left);
    tempList.push_back(right);
    childrenNodes = tempList;
    nodeType = x;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for logicalNode
 * @param os is the stream to be printed to
 */
void LogicalNode::printNode(std::ostream &os) const {
    os << "LOGICAL_" << nodeType;
}

/**
 *
 * @return
 */
int LogicalNode::getNodeType() {
    return LOGICALNODE;
}

/**
 *
 * @return
 */
string LogicalNode::walk() {
    string s1 = tokenToString2(nodeType);
    string s2 = getChildren().front()->walk();
    string s3 = getChildren().back()->walk();
    string s4 = "$t" + to_string(registerCnt++ % 10);
    vector<string> v = {s1, s2, s3, s4};
    main3ac.push_back(v);
    return s4;
}

/**
 * @brief NoneNode constructor
 */
NoneNode::NoneNode() = default;

/**
 * @brief NoneNode prints none
 * @param os is the stream to be printed to
 */
void NoneNode::printNode(std::ostream &os) const {
    os << "NONE";
}

/**
 *
 * @return
 */
int NoneNode::getNodeType() {
    return NONENODE;
}

/**
 *
 * @return
 */
string NoneNode::walk() {
    return "";
}

/**
 * @brief RelationalNode constructor. creates a temporary list of child nodes
 * @param type is the type of relational operator
 * @param left is the left child
 * @param right is the right child
 */
RelationalNode::RelationalNode(int type, ASTNode *left, ASTNode *right) {
    operationType = type;
    list<ASTNode*> tmplist;
    tmplist.push_back(left);
    tmplist.push_back(right);
    childrenNodes = tmplist;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for relationalNode
 * @param os is the stream to be printed to
 */
void RelationalNode::printNode(std::ostream &os) const {
    os << "RELATIONAL_" << tokenToString2(operationType);
}

/**
 *
 * @return
 */
int RelationalNode::getNodeType() {
    return RELATIONALNODE;
}

/**
 *
 * @return
 */
string RelationalNode::walk() {
    string s1 = tokenToString2(operationType);

    string s2 = getChildren().front()->walk();
    if(getChildren().front()->getNodeType() == ARRAYNODE){
        s2 = "(" + s2 + ")";
    }

    string s3 = getChildren().back()->walk();
    if(getChildren().back()->getNodeType() == ARRAYNODE){
        s3 = "(" + s3 + ")";
    }

    /*auto list_copy = getChildren();
    string s2 = list_copy.front()->walk();
    list_copy.pop_front();
    string s3 = list_copy.front()->walk();*/
    string s4 = "$t" + to_string(registerCnt++ % 10);
    string s5;
    s5 = getFileLine(lineNum);
    vector<string> v2 = {"COMMENT", s5};
    vector<string> v = {s1, s2, s3, s4};
    main3ac.push_back(v2);
    main3ac.push_back(v);
    return s4;
}

/**
 * @brief ReturnNode constructor. Checks if return is null and creates a corresponding temporary child node list
 * @param child is the child ASTNode pointer
 */
ReturnNode::ReturnNode(ASTNode *child) {
    if (child == nullptr) {
        list<ASTNode*> emptyList;
        childrenNodes = emptyList;
    } else {
        list<ASTNode*> tmp;
        tmp.push_back(child);
        childrenNodes = tmp;
    }

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for returnNode
 * @param os is the stream to be printed to
 */
void ReturnNode::printNode(std::ostream &os) const {
    os << "RETURN";
}

/**
 *
 * @return
 */
int ReturnNode::getNodeType() {
    return RETURNNODE;
}

/**
 *
 * @return
 */
string ReturnNode::walk() {
    vector<string> v2 = {"COMMENT", getFileLine(lineNum)};
    main3ac.push_back(v2);

    if (getChildren().front()->getNodeType() != NONENODE) {
        string ret = getChildren().front()->walk();
        string return_address = to_string(stackCnt) + "($fp)";
        vector<string> v = {"PUSHRETURN", ret, return_address, "---"};
        main3ac.push_back(v);
        currentFuncOffsets.emplace("_RETURN_VALUE_", stackCnt);
        //stackCnt += getByteSize(getChildren().front()->getTypes());
        stackCnt += 4;
    }
    return "";
}

/**
 * @brief SeqNode constructor. Creates a temp list of children
 * @param seq is the type of SeqNode
 * @param first is the first child
 * @param second is the second chile
 */
SeqNode::SeqNode(char seq, ASTNode *first, ASTNode *second) {
    list<ASTNode*> tmpList;
    tmpList.push_back(first);
    tmpList.push_back(second);
    childrenNodes = tmpList;

    seqType = seq;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief SeqNode print function. prints a string based on what kind of seqnode it is
 * @param os is the stream to be printed to
 */
void SeqNode::printNode(std::ostream &os) const {
    switch(seqType) {
        case 's':
            os << "STATEMENTS";
            break;
        case 'd':
            os << "DECLARATIONS";
            break;
        case 'c':
            os << "COMPOUND";
            break;
        case 'a':
            os << "ARGUMENTS";
            break;
        case 'g':
            os << "GLOBAL";
            break;
        case 't':
            os << "STRUCT_LIST";
            break;
        case 'q':
            os << "INIT_DECL_LIST";
            break;
        case 'e':
            os << "ENUM_LIST";
            break;
        case 'i':
            os << "IDENTIFIER_LIST";
            break;
        case 'p':
            os << "PARAMETER_LIST";
            break;
        case 'x':
            os << "EXPRESSION_LIST";
            break;
        default:
            os << "UNDEFINED_SEQUENCE";
            break;
    }
}

/**
 * @brief SeqNode constructor
 * @param seq is the type of seqNode
 * @param statementList is the list of ASTNode pointers
 */
SeqNode::SeqNode(char seq, list<ASTNode *> statementList) {
    childrenNodes = move(statementList);

    seqType = seq;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 *
 * @return
 */
int SeqNode::getNodeType() {
    return SEQNODE;
}

/**
 *
 * @return
 */
string SeqNode::walk() {
    switch(seqType) {
        case 'g': {
            vector<string> v9 = {"COMMENT", "START OF PROGRAM", "---", "---"};
            main3ac.push_back(v9);
            vector<string> v0 = {"ALLOCATE", "TODO", "---", "---"};
            main3ac.push_back(v0);
            int allocateLine = main3ac.size()-1;
            vector<string> v = {"CALL", "main", "---", "---"};
            main3ac.push_back(v);
            vector<string> v8 = {"COMMENT", "END OF PROGRAM", "---", "---"};
            main3ac.push_back(v8);
            //TODO I could put an ASSIGN here to show "process finished with exit code 0 :] :]
            vector<string> v3 = {"DEALLOCATE", "TODO", "---", "---"};
            main3ac.push_back(v3);
            int deallocateLine = main3ac.size()-1;
            vector<string> v2 = {"HALT", "---", "---", "---"};
            main3ac.push_back(v2);
            for (auto x : getChildren()) {
                x->walk();
            }
            int stackSize = allFuncOffsets.at("main").at("_TOTAL_STACK_SIZE_");
            main3ac[allocateLine][1] = to_string(stackSize);
            main3ac[deallocateLine][1] = to_string(stackSize);
            break;
        }
        default: {
            for (auto x : getChildren()) {
                x->walk();
            }
            break;
        }
    }
    return "";
}

/**
 * @brief UnaryNode constructor. Creates a temporary list of children.
 * @param x is the unary operator that nodeType is set to.
 * @param child is the child of the UnaryNode
 */
UnaryNode::UnaryNode(int x, ASTNode *child) {
    list <ASTNode*> tempList;
    tempList.push_back(child);
    nodeType = x;
    types = child->getTypes();
    childrenNodes = tempList;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for unary node
 * @param os is the stream to be printed to
 */
void UnaryNode::printNode(std::ostream &os) const {
    os << "UNARY_" << tokenToString2(nodeType);
}

/**
 *
 * @return
 */
int UnaryNode::getNodeType() {
    return UNARYNODE;
}

/**
 *
 * @return
 */
string UnaryNode::walk() {
    string s = getChildren().front()->walk();
    string s2 = "l" + to_string(labelCnt++);
    switch (nodeType) {
        case MINUS: {
            vector<string> v2 = {"NEG", s, "---", s2};
            main3ac.push_back(v2);
            return s2;
        }
        case PLUS: {
            //do nothing
            return "";
        }
        case BANG: {
            vector<string> v = {"NOT", s, "---", s2};
            main3ac.push_back(v);
            return s2;
        }
        default: {
            //pointers, address, and bitwise complement
            cerr << "UNARY NOT IMPLEMENTED" << endl;
            return "";
        }
    }
}


/**
 * @brief WhileNode constructor. Makes a temporary list of the
 *        children ASTNodes and sets childrenNodes equal to it.
 * @param expr is the while loop expression to be checked
 * @param stmt is the body of the while loop
 * @param dooo is a bool denoting whether this is a while or do-while loop
 */
WhileNode::WhileNode(ASTNode *expr, ASTNode *stmt, bool dooo) {
    list<ASTNode*> tempList;
    tempList.push_back(expr);
    tempList.push_back(stmt);
    childrenNodes = tempList;
    doo = dooo;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for WhileNode, checks if it is a while or a do-while loop.
 * @param os is the stream to be printed to
 */
void WhileNode::printNode(std::ostream &os) const {
    if(doo){
        os << "DO_WHILE";
    }
    else{
        os << "WHILE";
    }
}

/**
 *
 * @return
 */
int WhileNode::getNodeType() {
    return WHILENODE;
}

/**
 *
 * @return
 */
string WhileNode::walk() {
    string s5;
    s5 = getFileLine(getChildren().front()->getLineNum());
    string initLabel = "l" + to_string(labelCnt++);
    vector<string> v4 = {"COMMENT", s5};
    vector<string> v = {"LABEL", initLabel, "---", "---"};
    main3ac.push_back(v);

    string s1 = "BREQ";
    string s2;
    string s3 = "$zero";
    string s4;

    if (!doo) {
        //while condition
        s2 = getChildren().front()->walk();

        s4  = "l" + to_string(labelCnt++);
        vector<string> v6 = {s1, s2, s3, s4};
        main3ac.push_back(v6);
        //then do
        getChildren().back()->walk();
    } else {
        //do
        getChildren().back()->walk();
        //then while
        s2 = getChildren().front()->walk();
        s4  = "l" + to_string(labelCnt++);
        vector<string> v5 = {s1, s2, s3, s4};
        main3ac.push_back(v5);
    }
    vector<string> v2 = {"BR", "---", "---", initLabel};
    main3ac.push_back(v2);
    vector<string> v3 = {"LABEL", s4, "---", "---"};
    main3ac.push_back(v3);

    return "";
}


/**
 * @brief IDNode constructor
 * @param name is the name of the identifier
 */
IdentifierNode::IdentifierNode(string *name) {
    identifier = *name;
    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

int IdentifierNode::getDimensions() {
    return static_cast<int>(sizeList.size());
}

/**
 * @brief IDNode function to get the identifier name
 * @return returns a string that is the identifier name
 */
string IdentifierNode::getName() {
    return identifier;
}

/**
 * @brief sets symbol table node from an identifier node. copies types and size set
 * @param symtblnd2 is the symboltablenode to be set
 */
void IdentifierNode::setSymbolNode(SymbolTableNode2* symtblnd2) {
    symbolTableNode2 = symtblnd2;
    types = symbolTableNode2->types;
    checkType();
    sizeList = symbolTableNode2->sizeList;
}

/**
 * @brief Identifier node print function
 * @param os is the stream to be printed to
 */
void IdentifierNode::printNode(std::ostream &os) const {
    os << "VARIABLE_" << identifier;
    for (auto item : types) {
        os << "_" << tokenToString2(item);
    }
    int dimensions = static_cast<int>(sizeList.size());
    if (dimensions > 0) {
        os << "_ARR_";
        int i = 1;
        for (auto dim_size : symbolTableNode2->sizeList) {
            os << "DIM" << i << "_" << dim_size;
            i++;
        }
    }
}

IdentifierNode::~IdentifierNode() {
    delete symbolTableNode2;
}

int IdentifierNode::getNodeType() {
    return IDENTIFIERNODE;
}

string IdentifierNode::walk() {
    string s = to_string(currentFuncOffsets[identifier]);
    return s + "($fp)";
}

list<int> IdentifierNode::getSizeList() {
    return sizeList;
}

/**
 * @brief print function for IntNode
 * @param os is the stream to be printed to
 */
void IntNode::printNode(std::ostream &os) const {
    os << "INT_" << nodeVal;
}

/**
 * @brief IntNode constructor. inserts type INT into set of types.
 * @param val is the value of the integer
 */
IntNode::IntNode(int val) {
    nodeVal = val;
    types.insert(INT);

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 *
 * @return
 */
int IntNode::getVal() {
    return nodeVal;
}

/**
 *
 * @return
 */
int IntNode::getNodeType() {
    return INTNODE;
}

/**
 *
 * @return
 */
string IntNode::walk() {
    return to_string(nodeVal);
}

/**
 * @brief CharNode constructor. inserts type CHAR into set of types.
 * @param val is the value of the char
 */
CharNode::CharNode(char val) {
    types.insert(CHAR);
    nodeVal = val;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for charnode that prints the value of the char
 * @param os is the stream to be printed to
 */
void CharNode::printNode(std::ostream &os) const {
    os << "CHAR_" << nodeVal;
}

/**
 *
 * @return
 */
int CharNode::getNodeType() {
    return CHARNODE;
}

/**
 *
 * @return
 */
string CharNode::walk() {
    return to_string(nodeVal);
}

/**
 * @brief FloatNode constructor. inserts type FLOAT into set of types.
 * @param val is the value of the float.
 */
FloatNode::FloatNode(float val) {
    types.insert(FLOAT);
    nodeVal = val;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 *
 * @return
 */
string FloatNode::walk() {
    return to_string(nodeVal);
}

/**
 * @brief printer function for floatNode
 * @param os is the stream to be printed to
 */
void FloatNode::printNode(std::ostream &os) const {
    os << "FLOAT_" << nodeVal;
}

/**
 *
 * @return
 */
int FloatNode::getNodeType() {
    return FLOATNODE;
}

/**
 * @brief StringNode constructor
 * @param val is the string to be copied into nodeVal
 */
StringNode::StringNode(string *val) {
    nodeVal = *val;

    lineNum = yylineno;
    colNum = columnQueue.size() - yyleng + 1;
}

/**
 * @brief print function for StringNode
 * @param os is the stream to be printed to
 */
void StringNode::printNode(std::ostream &os) const {
    os << "STRING_" << nodeVal;
}

/**
 *
 * @return
 */
int StringNode::getNodeType() {
    return STRINGNODE;
}

/**
 *
 * @return
 */
string StringNode::walk() {
    return nodeVal;
}